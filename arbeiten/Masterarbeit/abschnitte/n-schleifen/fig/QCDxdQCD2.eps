%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.993 Copyright 2013 Radical Eye Software
%%Title: /home/dkahl/Documents/Masterarbeit/arbeiten/Masterarbeit/abschnitte/n-schleifen/fig/Jaxo_tmp.dvi
%%CreationDate: Thu Aug 25 13:26:20 2016
%%BoundingBox: 177 571 418 721
%%DocumentFonts: Fourier-Math-Letters-Italic Utopia-Italic
%%+ Fourier-Math-Extension
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -E -o
%+ /home/dkahl/Documents/Masterarbeit/arbeiten/Masterarbeit/abschnitte/n-schleifen/fig/QCDxdQCD2.eps
%+ /home/dkahl/Documents/Masterarbeit/arbeiten/Masterarbeit/abschnitte/n-schleifen/fig/Jaxo_tmp.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.08.25:1326
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 856 2013-12-09 10:34:40Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.21, 2013/11/28
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 801 2013-07-09 18:10:41Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /pi 3.141592 def /ed{exch def}def /gs{gsave dup scale}def /gsw{ gs
/width ed width setlinewidth }def /p1{/y1 ed /x1 ed}def /p2{/y2 ed
/x2 ed}def /p3{/y3 ed /x3 ed}def /p4{/y4 ed /x4 ed}def /garrow{/arrowpos
ed /arrowspec ed}def /setabs{ dup load abs def }def /normalizearc {
translate exch dup rotate sub 3 2 roll { neg 1 -1 scale } if dup abs
360 ge { pop 360 } { dup dup 0 lt { 360 sub } if 360 div truncate 360
mul sub dup 0.1 lt { pop 360 } if }ifelse } def /normalizeline { 3
index 3 index translate 2 index sub exch 3 index sub 2 copy atan rotate
dup mul exch dup mul add sqrt 3 1 roll pop pop } def /abox{ newpath
x1 y1 moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto closepath }def
/atriangle{ newpath x1 y1 moveto x2 y2 lineto x3 y3 lineto closepath
}def /abezier{ newpath x1 y1 moveto x2 y2 x3 y3 x4 y4 curveto }def
/distance{ dup 3 index sub dup mul 2 index 5 index sub dup mul add
sqrt } def

 /arrowVTriangle { /arrowinset ed /arrowlength ed /arrowwidth ed /arrowstroke
ed newpath 0 arrowlength -0.5 mul moveto arrowwidth arrowlength rlineto
arrowwidth -1 mul arrowlength arrowinset mul -1 mul rlineto arrowwidth
-1 mul arrowlength arrowinset mul rlineto closepath arrowstroke 0 ne
{ gsave arrowstroke setlinewidth stroke grestore } if fill } def /arrow1
{ gsave rotate exec grestore } def

 /fixdash{ 2 copy gt 1 index 0 ne and { 2 copy 2 mul div 0.5 sub round
dup 0 le { pop 0 } if 2 mul 1 add exch pop div dup 2 array astore 0
setdash } { pop pop [] 0 setdash } ifelse } def

 /dashline{ gsave distance dsize fixdash newpath moveto lineto stroke
grestore } def

 /dasharc{ gsave 3 copy sub abs pi mul 180 div mul 3 index angdsize
mul fixdash newpath arc stroke grestore } def

 /doublegluon{ gsw /linesep ed /num ed /ampi ed normalizeline /dr ed
linesep 0 eq { 0 0 dr 0 ampi num gluon1 } { 0 linesep 2 div dup dr
exch ampi num gluon1 0 linesep -2 div dup dr exch ampi num gluon1 }
ifelse grestore } def

 /gluon1{ gsave /num ed /ampi ed normalizeline /dr ed /num num 0.5
sub round def /inc dr num 2 mul 2 add div def /amp8 ampi 0.9 mul def
amp8 0 lt {/amp8 amp8 neg def} if /x1 inc 2 mul def newpath 0 0 moveto
inc 0.1 mul ampi 0.5 mul inc 0.5 mul ampi inc 1.4 mul ampi curveto
x1 amp8 add dup ampi exch ampi neg dup x1 exch curveto 2 1 num { pop
x1 amp8 sub dup ampi neg exch ampi dup x1 inc add exch curveto /x1
x1 inc dup add add def x1 amp8 add dup ampi exch ampi neg dup x1 exch
curveto } for x1 amp8 sub dup ampi neg exch ampi dup x1 inc 0.6 mul
add exch curveto x1 inc 1.5 mul add ampi dr inc 0.1 mul sub ampi 0.5
mul dr 0 curveto stroke grestore } def

 /doublephoton{ gsw /linesep ed /num ed /ampi ed normalizeline /dr
ed linesep 0 eq { 0 0 dr 0 ampi num photon1 } { 0 linesep 2 div dup
dr exch ampi num photon1 0 linesep -2 div dup dr exch ampi num photon1
} ifelse grestore } def

 /photon1{ gsave /num1 ed /ampi1 ed normalizeline /dr ed /num1 num1
2 mul 0.5 sub round def /x2 dr num1 div def /sign 1 def 1 1 num1 {
pop newpath 0 0 moveto 4 3 div x2 mul pi div dup neg x2 add 4 3 div
ampi1 sign mul mul dup 3 1 roll x2 0 curveto stroke /sign sign neg
def x2 0 translate } for grestore } def

 /zigzag{ gsw /num ed /ampi ed normalizeline /dr ed /num num 2 mul
0.5 sub round def /x2 dr num div def /sign 1 def 1 1 num { pop newpath
0 0 moveto x2 2 div ampi sign mul lineto x2 0 lineto stroke /sign sign
neg def x2 0 translate } for grestore } def

 /doublephotonarc{ gsw normalizearc /darc ed /radius ed /linesep ed
/num ed /ampli ed /num num 2 mul round def /darc1 darc num div def
/cp darc1 cos def /sp darc1 sin def darc1 2 div dup /cp2 exch cos def
/sp2 exch sin def linesep 0 eq { radius photonarc1 } { linesep 2 div
radius add photonarc1 linesep -2 div radius add photonarc1 } ifelse
grestore } def

 /photonarc1{ gsave /radius1 ed /ampli1 ampli def newpath 1 1 num {
pop radius1 0 moveto /beta radius1 darc1 mul 180 ampli1 mul div def
/tt sp cp beta mul sub cp sp beta mul add div def /amp1 radius1 ampli1
add 8 mul beta cp2 mul sp2 sub mul beta 4 cp add mul tt cp mul 3 mul
sp 4 mul sub add radius1 mul sub beta tt sub 3 mul div def radius1
ampli1 add 8 mul cp2 mul 1 cp add radius1 mul sub 3 div amp1 sub dup
radius1 sub beta mul amp1 dup radius1 cp mul sub tt mul radius1 sp
mul add radius1 cp mul radius1 sp mul curveto /ampli1 ampli1 neg def
darc1 rotate } for stroke grestore } def

 /doublegluearc{ gsw normalizearc /darc ed /radius ed /linesep ed /num
ed /ampi ed /num num 0.5 sub round def linesep 0 eq { radius gluearc1
} { linesep 2 div radius add gluearc1 linesep -2 div radius add gluearc1
} ifelse grestore } def

 /gluearc1{ gsave /radius1 ed /dr radius1 darc mul pi mul 180 div def
/const darc dr div def darc 360 lt { /inc dr num 2 mul 2 add div def
} { /inc dr num 2 mul div def } ifelse /amp8 ampi 0.9 mul def /amp1
radius1 ampi add def /amp2 radius1 ampi sub def /amp3 radius1 ampi
2 div add def /amp4 amp1 inc amp8 add const mul cos div def /amp5 amp2
amp8 const mul cos div def /amp6 amp1 inc 0.6 mul amp8 add const mul
cos div def /amp7 amp1 inc 0.9 mul const mul cos div def amp8 0 lt
{/amp8 amp8 neg def} if newpath darc 360 lt { /x1 inc 2 mul def radius1
0 moveto inc 0.1 mul const mul dup cos amp3 mul exch sin amp3 mul inc
0.5 mul const mul dup cos amp7 mul exch sin amp7 mul inc 1.4 mul const
mul dup cos amp1 mul exch sin amp1 mul curveto x1 amp8 add const mul
dup cos amp6 mul exch sin amp6 mul x1 amp8 add const mul dup cos amp5
mul exch sin amp5 mul x1 const mul dup cos amp2 mul exch sin amp2 mul
curveto 2 1 num } { /x1 0 def amp2 0 moveto 1 1 num } ifelse { pop
x1 amp8 sub const mul dup cos amp5 mul exch sin amp5 mul x1 amp8 sub
const mul dup cos amp4 mul exch sin amp4 mul x1 inc add const mul dup
cos amp1 mul exch sin amp1 mul curveto /x1 x1 inc dup add add def x1
amp8 add const mul dup cos amp4 mul exch sin amp4 mul x1 amp8 add const
mul dup cos amp5 mul exch sin amp5 mul x1 const mul dup cos amp2 mul
exch sin amp2 mul curveto } for darc 360 lt { x1 amp8 sub const mul
dup cos amp5 mul exch sin amp5 mul x1 amp8 sub const mul dup cos amp6
mul exch sin amp6 mul x1 inc 0.6 mul add const mul dup cos amp1 mul
exch sin amp1 mul curveto x1 inc 1.5 mul add const mul dup cos amp7
mul exch sin amp7 mul dr inc 0.1 mul sub const mul dup cos amp3 mul
exch sin amp3 mul dr const mul dup cos radius1 mul exch sin radius1
mul curveto } if stroke grestore } def

 /dasharrowdoubleline{ gsw normalizeline /dr ed /dsize ed /linesep
ed /flip ed garrow /linesep setabs /linewidth width def /y11 linesep
0.5 mul def /y22 linesep -0.5 mul def 0 y11 dr arrowpos mul y11 dashline
linesep 0 ne { 0 y22 dr arrowpos mul y22 dashline } if dr arrowpos
mul 0 translate /arrowspec load flip { -90 }{ 90 } ifelse arrow1 0
y11 dr 1 arrowpos sub mul y11 dashline linesep 0 ne { 0 y22 dr 1 arrowpos
sub mul y22 dashline } if grestore } def

 /arc2{ gsw normalizearc /darc ed /radius ed /dsize ed /linesep ed
/angdsize dsize radius div def /flip ed garrow /arcmid darc arrowpos
mul def dsize 0 eq { linesep 0 eq { 0 0 radius 0 darc dasharc } { 0
0 radius linesep 2 div add 0 darc dasharc 0 0 radius linesep -2 div
add 0 darc dasharc } ifelse } { linesep 0 eq { 0 0 radius 0 arcmid
dasharc 0 0 radius arcmid darc dasharc } { 0 0 radius linesep 2 div
add 0 arcmid dasharc 0 0 radius linesep -2 div add 0 arcmid dasharc
0 0 radius linesep 2 div add arcmid darc dasharc 0 0 radius linesep
-2 div add arcmid darc dasharc } ifelse } ifelse arcmid rotate radius
0 translate /arrowspec load flip { 0 } { 180 } ifelse arrow1 grestore
} def

 /vertex{ gs /dotsize ed translate newpath 0 0 dotsize 0 360 arc fill
stroke grestore } def

 /bcirc{ gsw /radius ed translate gsave 1 setgray newpath 0 0 radius
0 360 arc fill grestore newpath 0 0 radius 0 360 arc stroke grestore
} def

 /gcirc{ gsw /gcolor ed /radius ed translate 1 setgray newpath 0 0
radius 0 360 arc fill gcolor setgray newpath 0 0 radius 0 360 arc fill
0 setgray newpath 0 0 radius 0 360 arc stroke grestore } def

 /ccirc1{ gsw /radius ed translate newpath 0 0 radius 0 360 arc fill
grestore } def

 /ccirc2{ gsw /radius ed translate newpath 0 0 radius 0 360 arc stroke
grestore } def

 /box{ gsw p2 p1 abox stroke grestore } def

 /bbox{ gsw p2 p1 gsave 1 setgray abox fill grestore abox stroke grestore
} def

 /gbox{ gsw /gcolor ed p2 p1 1 setgray abox fill gcolor setgray abox
fill 0 setgray abox stroke grestore } def

 /cbox1{ gsw p2 p1 abox fill grestore } def

 /cbox2{ gsw p2 p1 abox stroke grestore } def

 /triangle{ gsw p3 p2 p1 atriangle stroke grestore } def

 /btriangle{ gsw p3 p2 p1 gsave 1 setgray atriangle fill grestore atriangle
stroke grestore } def

 /gtriangle{ gsw /gcolor ed p3 p2 p1 1 setgray atriangle fill gcolor
setgray atriangle fill 0 setgray atriangle stroke grestore } def

 /ctriangle1{ gsw p3 p2 p1 atriangle fill grestore } def

 /ctriangle2{ gsw p3 p2 p1 atriangle stroke grestore } def

 /btext{ gsw /fsize ed /thetext ed translate /hsize thetext stringwidth
pop def /x1 hsize fsize add 2 div neg def /y1 fsize 2 mul 3 div neg
def /x2 x1 neg def /y2 y1 neg def gsave 1 setgray abox fill grestore
abox stroke hsize 2 div neg fsize 3 div neg moveto thetext show grestore
} def

 /b2text{ gsw /fsize ed /text2 ed /text1 ed translate /hsize1 text1
stringwidth pop def /hsize2 text2 stringwidth pop def hsize1 hsize2
lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse /x1 hsize fsize
add 2 div neg def /y1 fsize neg 7 mul 6 div def /x2 x1 neg def /y2
y1 neg def gsave 1 setgray abox fill grestore abox stroke hsize1 2
div neg fsize 6 div moveto text1 show hsize2 2 div neg fsize 5 mul
6 div neg moveto text2 show grestore } def

 /gtext{ gsw /fsize ed /thetext ed /graysc ed translate /hsize thetext
stringwidth pop def /x1 hsize fsize add 2 div neg def /y1 fsize 2 mul
3 div neg def /x2 x1 neg def /y2 y1 neg def graysc setgray abox fill
0 setgray abox stroke hsize 2 div neg fsize 3 div neg moveto thetext
show grestore } def

 /ctext1{ gsw /fsize ed /thetext ed translate /hsize thetext stringwidth
pop def /x1 hsize fsize add 2 div neg def /y1 fsize 2 mul 3 div neg
def /x2 x1 neg def /y2 y1 neg def abox fill grestore } def

 /ctext2{ gsw /fsize ed /thetext ed translate /hsize thetext stringwidth
pop def /x1 hsize fsize add 2 div neg def /y1 fsize 2 mul 3 div neg
def /x2 x1 neg def /y2 y1 neg def abox stroke hsize 2 div neg fsize
3 div neg moveto thetext show grestore } def

 /g2text{ gsw /fsize ed /text2 ed /text1 ed /graysc ed translate /hsize1
text1 stringwidth pop def /hsize2 text2 stringwidth pop def hsize1
hsize2 lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse /x1 hsize
fsize add 2 div neg def /y1 fsize neg 7 mul 6 div def /x2 x1 neg def
/y2 y1 neg def graysc setgray abox fill 0 setgray abox stroke hsize1
2 div neg fsize 6 div moveto text1 show hsize2 2 div neg fsize 5 mul
6 div neg moveto text2 show grestore } def

 /c2text1{ gsw /fsize ed /text2 ed /text1 ed translate /hsize1 text1
stringwidth pop def /hsize2 text2 stringwidth pop def hsize1 hsize2
lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse /x1 hsize fsize
add 2 div neg def /y1 fsize neg 7 mul 6 div def /x2 x1 neg def /y2
y1 neg def abox fill grestore } def

 /c2text2{ gsw /fsize ed /text2 ed /text1 ed translate /hsize1 text1
stringwidth pop def /hsize2 text2 stringwidth pop def hsize1 hsize2
lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse /x1 hsize fsize
add 2 div neg def /y1 fsize neg 7 mul 6 div def /x2 x1 neg def /y2
y1 neg def abox stroke hsize1 2 div neg fsize 6 div moveto text1 show
hsize2 2 div neg fsize 5 mul 6 div neg moveto text2 show grestore }
def

 /ptext{ gs /text ed /fsize ed /mode ed 3 1 roll translate rotate mode
3 lt { 0 fsize neg translate } { mode 6 lt { /mode mode 3 sub def 0
fsize 2 div neg translate } { /mode mode 6 sub def } ifelse } ifelse
/fsize text stringwidth pop def mode 1 eq { fsize 2 div neg 0 translate
} { mode 2 eq { fsize neg 0 translate } if } ifelse 0 0 moveto text
show grestore } def

 /goval{ gsw /gcolor ed /x1 ed /x2 ed /radius ed translate x1 rotate
x2 radius div 1.0 scale 1 setgray newpath 0 0 radius 0 360 arc fill
gcolor setgray newpath 0 0 radius 0 360 arc fill 0 setgray newpath
0 0 radius 0 360 arc stroke grestore } def

 /coval1{ gsw /x1 ed /x2 ed /radius ed translate x1 rotate x2 radius
div 1.0 scale newpath 0 0 radius 0 360 arc fill grestore } def

 /coval2{ gsw /x1 ed /x2 ed /radius ed translate x1 rotate x2 radius
div 1.0 scale newpath 0 0 radius 0 360 arc stroke grestore } def

 /oval{ gsw /x1 ed /x2 ed /radius ed translate x1 rotate x2 radius
div 1.0 scale newpath 0 0 radius 0 360 arc stroke grestore } def

 /docurve{ x1 2 mul x2 add 3 div y1 y0 sub x1 x0 sub div x2 x0 sub
mul y2 y0 sub x2 x0 sub div x1 x0 sub mul add y1 add y0 2 mul add 3
div x1 x2 2 mul add 3 div y2 y3 sub x2 x3 sub div x1 x3 sub mul y1
y3 sub x1 x3 sub div x2 x3 sub mul add y2 add y3 2 mul add 3 div x2
y2 curveto } def

 /makecurve{ gsw /points ed /ss points length 2 idiv 2 mul def newpath
ss 4 gt { /x1 points 0 get def /y1 points 1 get def /x2 points 2 get
def /y2 points 3 get def /x3 points 4 get def /y3 points 5 get def
/x0 x1 2 mul x2 sub def /y0 y3 y2 sub x3 x2 sub div y2 y1 sub x2 x1
sub div sub 2 mul x2 x1 sub dup mul x3 x1 sub div mul y1 2 mul add
y2 sub def x1 y1 moveto docurve 0 2 ss 8 sub { /ii ed /x0 points ii
get def /y0 points ii 1 add get def /x1 points ii 2 add get def /y1
points ii 3 add get def /x2 points ii 4 add get def /y2 points ii 5
add get def /x3 points ii 6 add get def /y3 points ii 7 add get def
docurve } for /x0 points ss 6 sub get def /y0 points ss 5 sub get def
/x1 points ss 4 sub get def /y1 points ss 3 sub get def /x2 points
ss 2 sub get def /y2 points ss 1 sub get def /x3 x2 2 mul x1 sub def
/y3 y2 y1 sub x2 x1 sub div y1 y0 sub x1 x0 sub div sub 2 mul x2 x1
sub dup mul x2 x0 sub div mul y2 2 mul add y1 sub def docurve } { ss
4 eq { points 0 get points 1 get moveto points 2 get points 3 get lineto
} if } ifelse stroke grestore } def

 /makedashcurve{ gsw /dsize ed /points ed /ss points length 2 idiv
2 mul def newpath ss 4 gt { /x1 points 0 get def /y1 points 1 get def
/x2 points 2 get def /y2 points 3 get def /x3 points 4 get def /y3
points 5 get def /x0 x1 2 mul x2 sub def /y0 y3 y2 sub x3 x2 sub div
y2 y1 sub x2 x1 sub div sub 2 mul x2 x1 sub dup mul x3 x1 sub div mul
y1 2 mul add y2 sub def x1 y1 moveto docurve 0 2 ss 8 sub { /ii ed
/x0 points ii get def /y0 points ii 1 add get def /x1 points ii 2 add
get def /y1 points ii 3 add get def /x2 points ii 4 add get def /y2
points ii 5 add get def /x3 points ii 6 add get def /y3 points ii 7
add get def docurve } for /x0 points ss 6 sub get def /y0 points ss
5 sub get def /x1 points ss 4 sub get def /y1 points ss 3 sub get def
/x2 points ss 2 sub get def /y2 points ss 1 sub get def /x3 x2 2 mul
x1 sub def /y3 y2 y1 sub x2 x1 sub div y1 y0 sub x1 x0 sub div sub
2 mul x2 x1 sub dup mul x2 x0 sub div mul y2 2 mul add y1 sub def docurve
} { ss 4 eq { points 0 get points 1 get moveto points 2 get points
3 get lineto } if } ifelse centerdash stroke grestore } def

 /pathlength{ flattenpath /dist 0 def { /yfirst ed /xfirst ed /ymoveto
yfirst def /xmoveto xfirst def } { /ynext ed /xnext ed /dist dist ynext
yfirst sub dup mul xnext xfirst sub dup mul add sqrt add def /yfirst
ynext def /xfirst xnext def } {} {/ynext ymoveto def /xnext xmoveto
def /dist ynext yfirst sub dup mul xnext xfirst sub dup mul add sqrt
add def /yfirst ynext def /xfirst xnext def } pathforall dist } def

 /centerdash{ /pathlen pathlength def /jj pathlen dsize div 2.0 div
cvi def /ddsize pathlen jj 2.0 mul div def [ddsize] ddsize 2 div setdash
} def

 /logaxis{ gsw /offset ed /hashsize ed /nlogs ed normalizeline /rr
ed offset 0 ne { /offset offset ln 10 ln div def } if /offset offset
dup cvi sub def newpath 0 0 moveto rr 0 lineto /lsize rr nlogs div
def 0 1 nlogs { /x2 ed x2 offset ge { /y2 x2 offset sub lsize mul def
y2 rr le { y2 0 moveto y2 hashsize 1.2 mul lineto } if } if } for stroke
width 0.6 mul setlinewidth newpath 0 1 nlogs { /x2 ed 2 1 9 { ln 10
ln div x2 add /xx2 ed xx2 offset ge { /y2 xx2 offset sub lsize mul
def y2 rr le { y2 0 moveto y2 hashsize 0.8 mul lineto } if } if } for
} for stroke grestore } def

 /linaxis{ gsw /offset ed /hashsize ed /perdec ed /numdec ed normalizeline
/rr ed newpath 0 0 moveto rr 0 lineto /x1 rr numdec perdec mul div
def /y1 rr numdec div def /offset offset x1 mul def 0 1 numdec { y1
mul offset sub dup 0 ge { dup rr le { dup 0 moveto hashsize 1.2 mul
lineto } if } if } for stroke width 0.6 mul setlinewidth newpath offset
cvi 1 numdec perdec mul offset add { x1 mul offset sub dup 0 ge { dup
rr le { dup 0 moveto hashsize 0.8 mul lineto } if } if } for stroke
grestore } def

 /dashbezier{ gsw /dsize ed p4 p3 p2 p1 dsize 0 ne { [dsize dsize]
0 setdash } if abezier stroke grestore } def
 
@fedspecial end
%%BeginFont: Fourier-Math-Extension
%!PS-AdobeFont-1.0: Fourier-Math-Extension 001.004
%%CreationDate: Thu Nov 11 14:57:39 2004
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice ((C) 2003, GUTenberg) readonly def
/FullName (Fourier-Math-Extension) readonly def
/FamilyName (Fourier-Math-Extension) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -17 def
/UnderlineThickness 3 def
/Weight (Medium) readonly def
end readonly def
/FontName /Fourier-Math-Extension def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 101 /tildewide put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-32 -2960 6882 774} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DD8F6FC13F6
FEDF4B792B4382E1B8DD4D6B66F7698F4BD76CD673F74E2FFCF34A3EACBD4F3C
C6A935F0007CEC07779EB225FD87A32485FCE17DCF5D3B7363F4BADDDE608D74
12F1DE5225D1BC9EF64A528CBEAEBAB7C5CA75B68EE58CD3BCF098C552B2A1FB
75BF21F58BCCBC9B908C31E373408147528CAD183940FA19AF923D72ADC1836E
428B74A5B3EBB55F5B6E33E8FFA3025EABB8E4A824D430EC40A31F0D72A210DD
75759CE62844F0F7D49BA3D4BD6BCF66449B9AFB9BE875F751E394E0A4FCA52C
D8C522586A8B3F3C5C7804B68E3155F94CC622FBDDBFAD41C583E43FDFD10651
DD5434E0FFB349BDD07170A0FFCF4250E226F07D9C2CB416DDB63CF486B33CC2
389BF90C05271234DD30D97680F6B41F2F0B28FE0C84893AC64BF925683F8DC5
3DF4B96610E5CED82A6C57C1FB68FDBC3B4B88424038E1CFDC34157B77F9B99C
F81577EDF8A82CE0C6DC7397945E5E5C192725215EEEF3F0D0C2221C24A174AE
4D6E8C782CA8C003D204EF2DDEA75F563DD5FB33095F872BC457CA43C979BB8B
2E1C6DB52A659C726EF3BE8A44E2B2B189665BAD3029377EF989951855031A46
35A0F75CBE72536243DDC09E4D3B70D9EC465BA6941D05D1D74BFF1C090C9996
15ED42A15A4C030CD533FCF76E5546E83980D04F8DD9962B460B3C60A99CD0FE
7B537712FE685EE1FE724EEA199D4838F94802526E95371E4CF3286C1E798B32
A642F4291525C954A6B2BDAEFE1DAD4CE1FB64C375A74D82F10CD0CF9F83475B
A369D5E80CAC68B65C1FBA3BBF19FD3F7506F865DED7E3C2BFCDCA8223A756E7
A64DBAE9A000A5B1A7BFDAD6C3B8499D996F3AFAFA8B8FD730689EB5A2F9863A
C37F150635D4704407F0211A155FCB44F71B3987A2536531AE0C9664D6B142C0
06BB67D226D4263EECC79DD1C5CD4851F5752F651EECAF9454709210949AED5B
D427C6498ABF42B20E46F937A0D00449005601CBAB973BA69CAEAD5ABCB6BA97
E61E1F07B16B2D7D838AB032E9C8DC7A2CB6E698AB4200A8365C58DB3C461B6E
6FC9D52900A33A90FF645C595DD6CD113038381AB757BF0337C89E5EC96569F7
A1D97A667C2C827287C3291DF59519D6A15F85C39E7C414E14C40F858EFDDE11
DFA9A87355DACB6771227F2562D9B0F871A1D6CCE6B6E49F533AAD230C0A3CE2
A690A23BC05B182853321BF0DA3AD6C1D5BE3DA2E99E8BD52308B4665B605C96
FCABC7492FAE4547F01A78D39F9522E8B859F8A683FE6790142677AD88FE773D
0527B983655B415E8665CB880FE38261FD9C11751620C2C51DC54B36C45C7DAF
117B01EEDC0219E05529DC6F898E35654DC6
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Italic
%!PS-AdobeFont-1.0: Utopia-Italic 001.001
%%CreationDate: Wed Oct 2 18:58:18 1991
%%VMusage: 34122 41014
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Italic) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle -13 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Italic def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-166 -250 1205 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DA8165ADF55799A329EB45
40E811F9140E5296B391A61903BC09B76E7BCF96FA1EA22ACBA9ED962E9BC596
BB22E4A514A5C551107BC74BACBFE55ABADEB1741C20BD80A186E49DD89CE033
CA0ACA0D0D4188B8A6FB40C265A88804443A7E912005A6BFD10EBB43315F7A9E
E8C24321131DDDAE6572BE67DE42C5969688AC1D7EB97887D783F63658AABEB1
FA4C2F625E6B6205D3EEC1C5E2FE8C29BD88FDF52802F3F5BACE6AA2007FC0FA
B6CE66673C1D698F51457AB1343CCCEC0D2FD0383BE98493902021E1A27B71A9
0BD0DC94B4C46825738C15B5E101C68813E1F8C8B19311648DF09363FCEF679C
E691E13CE96DDD1455A75181706F41EA2E0A6A4C870F7D3726547BAD35E0EE54
7F91EFEB803E93D1A9BA74A332EE4E56CDB48AC36A47B9B555997C7A58C3A16C
8D71BE01432D88B842B5D9ACAD19FFF7EC88B4E66036D2735311AA323BDD69D6
8CF32F9AA7781A2146E04D71C54044218DE26A4EFEAF67EFD04E4ADE1D7FE2DB
61A465957450E623CA58FC49FA2236C0BA3E81E9A9FA8909261A4A092AC9640C
08CB2AF3BC1E92E578086556ABF6A1F739582230AF46D4C184714197545BE932
1FE1F05FA46478BEB38010C2FAE84145D367FA53B10F42B7B7BA76B427210475
71E67A52D8EADC847639F0BE7F280F35EDBE34C7FFD9907E796F373015965E1C
FF36F43C653EA3F23B76FC2ECEF9EC19D5BC245369A690C280DAF9F3D8401A08
95D0FC1C3F0C033AE23062A80A3B8A944F642986A878A0284CEFB15CEDEA1347
52978AAF95DD252EB0D606F78C7E295BB640D1153A3A0AB2A191B9458436471E
A80334C07C23E3D43BC2A56EE61DFD9FFDF3329FCD4DE9A7CF92ABB65FBCAAFC
7EA124656746FA3B8D5E8C9B51642207EDC0600CA659E44717F2BE08C400AD76
EA2E4F62AB149858C2DA5051009ECCE091A6E497D4729FC9924FEC3FB6A9133D
6B463F7C7EBE4EF91B9B17160941AC0087818BC60EB64E687E9349331FDB33F0
7E1D24C34E9E439FB6C392AFD85238CFEA21292B8E1D0991D029790B7831A2EE
2FA82A3B52599EB0636EF92E5D7C13FB08C67361F04482BB6BFD44CEF14F39F1
21263707E73B9BCFEC74AE58A63D5C3D4D773182258E76E62A5EC2865FB5951E
70F9FDECC6604E7D7A3A56648C90B4F400CD61B0B1ABB6B2EB9F977F0DC1A090
109733A75F2CCFBDD27403DE02C363DE41F7C24249DA6FF6A943A97302E113B2
7C840C2A6EFF6442DD52B43E21BD247CB559F781ED48E700C7C6818380E335F5
C15409940D60BDEE0EFA73595159BF5FA6EF014B844C996C73F53F63A48C7F4E
CEE23E1680B0037EAE119E8C5E67E32C964A18B5D20E9DA6FA4E53156DD528AF
830015D7D80E0A7974FC52EE48924BA4AD2AEBA3156D5F5916537207EB369B2A
6B80A8A4B044164ECE1C1FD5A30B240DE3246DFCBBD6E7EF71B3F46D35AF2EC6
76BF005985FEEB5D4A9ADD84C49132594E273D0A94C8C2DE65B5AA436EFD8768
EC53F2288DC8C1B20D1AD0FD1CBCEE7CB7349F8A7414179A76BEB45D64F98101
3705AB6F7A67D8551E4BC879A6461046CD604D79E621DD382967329A7EF603C5
0A96E000463F8247D7CF06FE08AEB09A6A8F4B0CB143A6C10B1412E1AD8276E4
A5A5219AECB4DD34412429A21E2A5209AEC889B4F6866F253442AD370B0F1417
DA1FC08EC0FD5DDBA32693D3EB2AA6656DB562DB11A93A95E2EDF7D8FFC0B7C7
757FB2F07EE0AED83063FDF0D7E87C3023794BB67736570C57ED61B8B603FED7
D22CB03DE9CF84D0727A880C47CE3AB280E335B52AF04530708DD1EC2EF27742
8F1B7028415CCED37F398CAF586AA3EBDC175A5537A59E478203E2CD2BD221BB
041EBFA5EDBAD3EBD63A8A30DB997012CCFFF5A79D1CFEB8C95B6FAF1BFE28F1
78D4125AC4957F58F65496A5549AE14CCE1E57ACCCE7AB5C7220A9E98ADD70AA
9F03070D98DA8A349322561746D69F860DA401B142B714143CC7DB577CFE5BFB
29F04614DDA700276DBCBBF0D3A7F5DC2C1BB86179CA9B40078FA02702A17FFA
E518EEBD72E9B9F45813376DDA3ADC6091566FFA422188BC928DB56203DD8A41
EE4E5A3F0CA3B05D6DD981F91D77F997EDAE05CF60692A2280D89FD0770312AC
D1605720870A3073E0D17527FA33EA465BBD51FCAA7D8BCCCE1AB81DFA802D4B
690A84909F10FDA8E19C96C0FD39A687303EE077E704F456BE47D6542B4C6CD7
4DC91DA2DBEAC3E1A4CFB825808326E51293ACB71C472FDA891AC6B7C95F26FD
5A8056A67280238497618BBA0BB81B2B2CC88F44955777DD46AC20C0E2F133DD
294C2EFEEBF219576A29BBB2BB2F0FB1814F28DE13B974F82CD044F76FDFC1A9
7D522C07829B89C59659959B7752F6ED590A086977052B1792124D00B4AF8096
19233096DC876FB3C6856091FCB2AE350504D8D35D69099147ED09C0EB1CC751
96875A3706D05940DFC5338AC897D640B2273609FABA5247D7A25500A0687896
7437AA9EACFF7CC82CF99AA9868EA9BFC8C95C67E18F56CB1C9658C5CA56F19E
724FC13FA1235757AD4D71AF0B943E3C595AA32928A759EF5F075284E77C21D7
CDAC569C93B637D314982D25D5E607D21C4C6B5E4238967342D7714172F78AB6
AC9F95CE14D6A52B8964407D2F0405FC314ABB33208C2AD5AFD96CFA784882D3
E8127C7CB6B67B55B288E94114143E04FDCDE2ECDFF67CFA590E1FE3F9A1CEE4
58D417ECC0DDA41F7634D5A9285B9CE92A31C0CCA60576BB99414899822E60BB
4B7DA8F64AB8F6CACD8C5A0C4A3FD41C847AEF6E83185AF5A4F9044794B3667C
EF087941C80C0A436F5FE68ADFDD873716717FD0AEB1F1A45AD147703831E53B
620C99CA2CAC35CEE0EE45D3B0A81E58BDAF63E8792D4B47FE5D968553B6B99D
09F9AA65B4D2BCF58254854EE4E5537AB5AD1310EA0C42EDDA7ABEF0AFC19E71
80661A594022B30999FEB929872A0333D54882F75C34B1C0A23DE389888C656D
9762E752A3B244122629F3C62DEF0159AA3639B35A95D0E92946286EE0A9BB4F
DDFA475AD64E84A11C8CB3EA31F5BB34389E8677F9FA0C1D5E1D35C64C2AF35A
3F992478D62CF4712683C49369635EA0435C6B8CEF3FF173464EE2162E1D1EF6
4D28ADD2062DA1D8F6687FA17E1A3496D74CD38A9C677596334DAFF3A84B780D
475231DC7C78D8B6B51157F3A19B5DB1BB9D419B3E98788FFF9E53D88C40FCBB
20052C5F3D12117ADB430557D38BE1F131E096A4216CCDFF127E5E7B94D00E82
832CA2C7C01110020767B5AAB758CD1156B969A988BCE55A9E86D2874B626EB8
47FB74F85172E2CF61496F879FBC5495B6C94389DF0CCE0695D3596B34E2CA98
2A3DC32B37F0649ABC33EFC47660F042D88C40FCBB25F68B8C5949D1975143CE
7B35A7787F7AEBCF09E5638B2C6B34B53A27A4DDF49EE7703DAF38098846BCB9
C471E8F53224B22A04A78EF3F2EECC580967BCF236FEF6DC45FD9A1AD1EFBD0B
82132FE1FFDDCAD30FC9639617ACB8B6D5F3B8EDF9E60E890CF427CACEEA88F5
36216569481872D2634DD0B9B61219913A5C930C5B0DF5419CFB55B68940602A
E0AA7A23A7F582ADFECDBFEE6C45D4B46C51F84A535127EA88C7C172D50A7E13
53649873CAF8B4E5561AF40380FCFFD60EAA2DEB40A3DD61EA97173400073C29
27440E424A723FF0D14A8675EC0B12990194A6B2D58B90F29206BB92A3F80117
7BEC1F28EC7B1CBD08E32F31FEF4DDD789D38C643B25F7C85F07715EEC3674D5
1977C31181D59149ABDD69221A28B39ACB315A128453C9B7259086086D5F97FB
210D86CCF9B92B6A42E07E45EB7D1271EAC07240CE0811225961151CB81B6C9B
6FEBD489C0E4B2B60A271B585DF66D49EDB3DDE567168FD2A18582D312DBBE9C
977358D447BBE693EFD4C574316F84B6B8B1D64A694F1331B64C945FD81578D8
095E63F70CAADDBB3C6B565D24CA24813F1B475AA298B8BE48AAF7AC7CFE4BF7
CAB4B4FF149430A1329D8B87FD17440CB0F9BDF60A3862F5A62C4087473D33AD
7B82C1C2BE1BEEDE3829DA2413AD86825B3FF021709810ED004976DC33831D41
3F6189859632EF656F1B058909F25BF6B5FD497380A30DC4160E222E43116C80
E837DC743CE4F3D621652DD601A5BDAEBD4395D887EEFCA9B9946706637E2573
28CB63E1A3F025611D5D428A63463ACDE9E5F075FE41D9B538004C5FD56D210B
185F12CA7EF18181FF17C705955E560ED3D1E81973D800E71265E7E72867306C
8D60239ED539FF8E32AC2D33BE96ABE7D7092008E0E5D2219DF06B654E4EA1BC
397412F9D12BF3C580D3113D84084865FE31A012031F36E7202BE4E1B1ED7B14
E3F49E527C371CA8B9A4450D95B165E060B5F197F6E45F73A38C72EBD68B46C8
7FC9B390059F80085285B65D9CAB00CD6A223B219D994A616CA9D2C6E03FB05D
0E4AF32B0F5E79D444A503B56D7CBB108D62C41590DD74A9546DF39E82A6AF85
53E18D5C5D184F17B4FBAE0876EEB94354DAAA29F25E002316940BF97D7446E7
06C9577DDFA1EC3DEC0FE840566D8413D9C38FD6FDE66D917CE92E3DAEBBE3B7
275F869ABF3878E34963B0297BA9F0829E9E08BFC40FA5025BEA2CBB5AE31855
6183403670A11457E5626EA0B2D2FC417A9122B7E3A85871FE57304AF12A16D5
17E8C75200E445788AFC588C6A93CEE3E8A0260AB1E11B361B175A109B31AF0F
4548B862BA6A61B89BCF7BAF9833CBD21550FDD160DB55673A6A7A4A84FAD031
1BF204A6A98400A884036139595B1C1550710BE5A47692A3089B2F8547D92FB9
49EBCC7827EBF718080B57E132599FDE2CDF6BDD441DA42B88E2A7EB35CC471B
55FD8007283F091EE032560D7A64F4AACF32D4364A9CCE507FE145AC58400E64
7968BDA608B659705098D4582889B2A8D918E9EC124E5A355BB7F924228C0921
C2300D620FCB3CC9B0F80719C82B4167589C59F314217A2172D9A8D1C1D18C10
DD9482CBDACCE2385270883A48B5A65215B6221AD668CC571AE15F125C8E145D
B5DFF5060F08149ED11849D17B5DA8DFE0988D81FD90541088F498129F2890DA
790C2691959B862CE68A420FBFC19723DD62E7C363134DA775669445A71FC40C
B2CEE8BDD8DD0E3B559859C6B14B2BBEF7E8CBC0A8536870710FD9BB63D4BF0B
F9887CB3AE78A7029671F83B6B90421B6CF29EB0FE77777D8D57443EC42BF0AB
B2EE786C5713E1E54BB8EFB775C3DF386E7DB94CE8D2503F0A72F0EA5084E4FE
D0634F18648507B20F4C7470DC8F70564DC6B71552881EA77279F9D19507801C
9869B8070A4F35E3F41F7FCBDEE545EC866315A7AB7675B5FC5B9BEF4B041AD7
7214C80F6A8F8CF912002BDCB3FB555CBAD20AA538A04D4354E1D423DF15AB60
242A35676C0CF80185A1DA69CD4B58AF33AB4860C32FE8128D863BB09F2D2E49
DE1DC7670F52424947B6C8A2FA32F58C15FBDD5D360181D708B1BD1023624133
806E42EF5E1D41A8DBF2E77879A80950BCB623AD7301A51CD25C6D3DE6269755
7282EC4820B161598D679148E31B5DEA54A92603DD99A134E2C53C14252D23DB
3E4EB8D83F6BAC2D60B3946D7234C575AC3F7C9BCC4258DA44963FE1431E89E4
A8B62598432F8153AA81A07DB02F5E350BA327EDB324C6DFF22FD9AF17D591C5
8552FA90B55181711AB819B07306C44FD8E1E542B5127D2B7664F1F9C16145B9
4B8234219527112FFF11380DAD73C64C193691F0605A719EDD49E456C0275C76
A38D4011CA6510AE65C7F2726F845BC5E78BFC5BD4EEA4AAF6FCBE1760A1463E
C3CF8F4C3A233E09D8E4A6D175980F5BA0510BE406066F0195F181DA6358BDBC
15614C89272DD4F4324B6D4F810116CFDD2E0F1DCECD505DC35CB149E68A4ABB
FD0D3C7BACDF0445995D4CC6CE9D649F9B7D6F52481694A6675AB3A402995166
07B892A03F846E75B44ABB275CCE89431F8B365C70EF98246C208F653DBA3BA2
DFCDF905F881B20845682DCE85BE27444C5C2EE1F17A3751D72AC738963B60BD
F1033C3A9324B5BC879E714EB71DF90B928C437A48B1D7B2E5803D91C6E71959
695DC59C52F8C7928DAE4739707500D7E6362E528CAEE040F7768EAA14EEEDB4
24D767E2103BADA0E97093ECA4CD41BE9E4555FFFE67565A8772E1250A760DB3
1625CD1A8BE66284BF1940F24190FC19948EF5E456DE009C5DB2BD9121606C72
C3B9EDE604CDAAE147B9BE353F97136431C59381BBA33B4734BC47F3A3275A3C
C503AD83DFBC5E2DADABDA6E32458ADBCB1B650A4FFC3E57E36EA5DF3D6292B2
A375CB7C3428A02515E6BAE950804EE5E469A0E168DF84A748F021AEE121E204
3AFA2AA91933A8A08D0B94E931CF4859A76FC0056E9F68CEE73A2EF39DE412F2
A0589CB8815BB33A40C3FA4C6AB9A48D0EEA39A25607970652DE1252D6390A87
1E6A19CAC1B40E52D2DA7E72E57DEB9A20C3850DDCDB9FFA16ABFEF928F1E28E
92D357DBC2F3CD7D9A7C8CCC4B183A99D3D180D673B740C302DD8C27150D8CDB
8D2372D7440A7BE139376BE0AB7233333E9A1D4A4785C25F3EF565FDCCB032B0
61AB58683A321AD84ADE1B9315324149043E7100D5A9A4D384ECECE95A6EC560
809F48CA3794406C8712E36D1C8D801A2F15B1C4B9371E39055E86180C4F03A4
7E29FB0A6DC59F9EB1C986FE7A9F38537FF35810519394220EFB10C66FC7FFDA
0F058CD38EDB16E799AD04298D94840DCCC3A72D6E690DDB982F55FEDD2379B1
113D100703A42D3FA1D62FC01C25913BC47F800907EF65D69BBBF89E6CB34D20
0F70D3AE26F2012A6E3DD7AC3D53392F77DFCF7FAB77051B3CE85372C05E1C5D
85FE330BCD2558CA8958F05CA09EC0F53805B0873D4E9589894110FCB86753AB
0F25FCA6BBB47C88FBB7CAC0AACCBCF08277419D50610BA45F203117169AE6FA
BC90CBB9172BA3AAFC6FA5FF97B51848560BE3E6370F84F134983AB4AF7BC6DF
74FFE9323E0DF559F1BD86E3675C3ABC3198DC0E0A7B0B3A644C7B083B38298E
FC48B276754C98464FAF0D6CFEA11B269B71E48E02A5A9EC40CDE174513BBF68
8CEEBE7DE00AC57C8E9BD580B65EE0A3C17C89601CC59600FE03E37C6624E62F
916E426A7538C6706D29DF0BCA295C846272F1FBF5430920DC02224CDA1C29ED
601BE2B6EFA6CD05424C4A973F65991F86E5848D7D8CCF7F3C5F26688213003B
72CA6F9BE8F1EC130930C2F370625BDE769F8AC60547A724D00985F7ED4D8589
7E29D8D0351C31A8224AF0ED16190B173E5C99CB752E8167DEA1649F5394C498
65F8162C27F5826F5D00BD522896098DC7529181B8A970D339AD47430A287D7D
38E907DECA0185F52E2D529D8ED4C1B8B7230CE676B407C8A60296C19AD40FE5
0F554FF34F301F29BA4CBF2C488BF28699B348EB368544F645DF7361876A7638
3FA1A5B5F00DA458BC77A371375FA35BCD767FEE7CEA849F3EFC997364B48A6B
F6AAD3F1CABDC48E91648652BEEC39119B6B2EA9EB9BC084F5A45A2CA82798F8
A2BBE9E49B094353D7859EF2E693F327D25D98FB44F53273DE6878DC6D41B5BE
8C6F4A9032FCFC5AC382DC237A96105EA6B80D4DAD9B9CBEF701D77D05CEC5FA
3DA9FACBBAA604AB2CFEF7BD716B2401FF59DF84DC27B11B307F385FD2379BA9
044DD214031FE8017EB2E0DE91E58DE438F3A4B1170E2D84159447E0282F1A28
CE3432AEF52FED83FDC43699EAE566BA213B1B4DB2B2F16E9BE2CF4387478FAC
37F415FD2F8E95EAB216693979AA13178DFB8148F709947E40893C1E511F85D2
D28582581DF7CF37E576E350F26EEAB86C4B8DD564DD79A093A254983196E958
BF6F00FAAA36C9E55516479205F6ABC9382A31CD26FEDDA044B82918D05D156E
C9E3CDD2F0337B0E120732B7AF681EC09F4239913E3F79BC527AAC58019BEBF5
C89BF45559E0513C640AE847681812E3B3FCD0626A01BDC2568BA1FE13F9FD81
56CB4E65D9BDF3AC3BCC2FCB25CE3F5B17D645ED8E4918A8ECE0DECCF5A2268C
0DC6434C00771CF4752F6B56546D498C0D5D46074A1CC0EE1DA6B4E6F212AA63
FE94C578022A689486AF779897C8E757E0EDED1BFCC3D181378276F28F98DAF7
3F361E238FC47EF3AA4CAD2FE404C3439539FA5A9F1C7509EC693369985223C5
9D2CE7BCA06ABA98CFEF193360EB7C2C60EFBD1A5C3B4A3F73E738FB16631AA4
0A5F8D1038506BF8246658BBA302079C03EA67F825B3B240E1E7C6244BE76CC1
454770E45AFED209C4511EEC00885DE7B36898F4E77A8B95579DECE928ECD4EB
1388784687563CBE925F25B7264E13B8F7563F84DCBC17655543E6B1F15FF25E
EDC2E24450748AE0AB34792AC865BF24C35C73E1A5A2439098AB0360478C7CD7
C2D1B62EF4BCFB0B616536900716DB8617421176E0A434A2486C0C4E1D829237
6172F6244AA16A6FE531CCE672487EEAB7641FC618728C410B5D21CF721B288E
1FD9E80ECF7BD18A61133B4B1343BD8152E3FA121F9BEFD2D0497A8FF4B6B1DA
432602C227A2F0C3A8BE6E7E34A8AC19BFD6E77B231F80DBB525C8D12B6346BE
F03D4E3242D9A72A4F6E225D43CB631659A61C7C1E82BEE2D005A5EFA732B2A6
AB3CA4EB65A549EA5111F668F6A9F6A59498FBD0CCBA3A05B269A23E831BFC83
958294E0ECF0C3888F23C3803C636FC56ABCC3EA9627DA1B828DE52FFDD3AE19
4DA3B93BF851F4C6221FBED7ECDFFE23999B83B0FD74090B0F4888B9B7859EE1
B93A02A9979CC2DECD1B139341F5845B4D5A354BAF9A5B2A3CC280A93EA38607
CFA4E74157BA19EC244C816F691B655E79E3E5F9830D5AF0E912142E5728CD5D
2CD7B2C34B54629ED814B9E66FD4DD31D76F77CFFAEB0917B3F439BFE60D1BDD
BE830D3102A495D48B3F40A192FE7D550F6C61CEE926D2A53A3F7CD0D66A33FF
4788F8D84CE7EA2B2561605354674E86264A28C739CD02A8BEBC5D665A5B9D97
BC6265F462A15DB507613183C0F18DB4794056651C2564CBC6CBB52E5D75AB46
AB2F000A9CD301B8AC3D8C58EDA6D539C11187DE4ADFB2C258B6D6447EC1B4E0
2797084C1003198ACC5F347100EE55B774A3109FDBBE87E9A74C5A4DB8771EFF
3918420675DBF2E804071E0D2C81AA5DCF2894D2569B43E9F2743DB4167E9D25
81295BECA7EBFAE1AB30DCF9BEFB1B803E6A45B66AC8339FB858FED838E44365
AC7E6D6DDE336D4B5FAD164918688A79FADEFE8BC6A7A6547AEEE4E8F393FEE4
66B4E1835A99C951B52B9F9D6DD7F4307D6BC1E31CEE59A30E3FC36612DA5738
106F94838CA9AD4C61DED60F0FB0557AFF2FB349A38647C2EF1682A05AF95652
CF8B3D7D321F71A894301774B91FD7F78DBACBA7A4ED77EE17791A6A7518A7DD
916A5E4571236C82FDC11833C9320C9284E93D668458CE61FA4B9A8A1F4DD151
0066DC28A51922FCC622227A6A71F3D48088FE8480F8CC8E24F7E5E17BAAA57A
795E2BE005DB70C69E5A25A6645BD38AB8E171F432F3A1442A00A02155AD7662
D1CD36742D56059E5D994ACF0F5FEF08095807440EAE4C0089180EA5E3BE297E
FDF330AAED96AFDAD8744D0EA36151A9470F1F504644EE71DE3331323D5907DD
D3DF6355F70A27F44E3AA88DD6CF07D37C229145A2A8735299BFAE5C40688DCA
F7667CD7504E58C87059CE0EC736CBA667930EA8EB90A0E06301E09E13004F76
BF206B0418863494799AB93D78CD0DEBA567BAC3EF005C7B3F1FF45FF489BCA0
C6D98AF1676928CC7967C259D71C4F0C11087A077D1303186A29C6856BDD8DE9
EA2AB4D75108CDD5C40A5DB870C2E63B9996778BF397FE68D98062B2D28844D7
1E8DF860C8E70A93B02B52B790FAC2CB062DE05F1EE5CEF9C28DC15B75479368
25563480DE35F7303C6F6E9A5D3C067295288B4A93097791EAB136D8E82FA466
7DCBC8EAAD98A3CF6E86B4BC6B4C39EC62ED27A18EB66FE8532B2CD412E53E31
437DB73F8982F2C051BFBCA0987DEC8B3BF9119DE84556FF555E3FD931E5E03D
7B9BFE305B9AA1783D0E2E7F817024385F1E9C6AD70301B128F18E1616D62722
ECD14BD2F86DAF0FBDA9E00A55E3AB079FF280D7D262812F0495FC898F22ECF1
B999219FB9F412824A3C5699BD29F7CD8EA038A4DC908A0C47C1195817002375
2D7D79A145541628F6EC350F3C3908A7469ABAFFAB8559F40EBB75EE3024C1DC
E8A5C8BD4703EAF3D879F5B0822B1EFF4166BA9C8736510624D9696EDBE6FBA1
94BE43CCCBA5B21BA0C60A0A51BA7D3E82FBC4139B0F7AAD04388B2067D000D1
80D75FD0F744A1473848BEC02304B6EF172FCEC9C847116E7BC9E4FB523667B6
246167D5462CD5E4D0BC501FCADC8E041B2C41AD66D3EC9331771176F71E8FE4
FF408D668E9D96762CBBDAFB0015F8B9B250DDD47CA234A1FC24C9DD6A16E026
DEA02B7D2795CDACC4AEC3C9C36951E3AD2213A81C3D4798557276FF2374E36E
A9667E98135200D242FAC288C5519058625F9BE81F4CFBB6F0863ACA4DB832CD
33E7EBA0AE1E9BB5F525BAE9FF2CA142F159C3CCE2E2EE6877C450E3B1700DF1
959F349B12BB4A8DF9EFE6E2CEBA5F3AFE76608695FDDA737BE911DC5336020C
527A1F1493A54F1EFAACFE83018EB513BB49C93725FB0F7F663150121177F215
BD3783CDF9176E9000A4C4DFE275C4C5C7864FA9654E52C4BB7A8C1A4EE53B17
731753936BF8271243C7E347570AD63C55C4DF2EDF539137A248D6B91A6F82FF
CC4145600D2538C1F263E992BC09D1B6E2F91CA42D36D3C1FE63DFD2EA8442B9
5AC52FE635D7DBE1EC3EA5FC1420D163BFA04177849E9CA1A46C02C5BC4CEC9C
8A4F0EEF4BC7640A87700186BF189636037EA724A2484036867EFF64EE4736ED
E4ECF1BAE72C82CA3579BB6074059AAFEF431A32C7E33049FA1970B5F2E6363E
50484DB34647179FDFCCC8DEF11001EEC69258B506DBE6635CEED304E60FBE37
3DDA7B54BE6D809C3523159605D5019813776E341A92A503129E1CAABB2CB8CA
3E598D5191CCF679DB1DFADD7DF27A7AAE9C74E18AB38C38BD2CB796962E5BEC
B5AF94AE88F49420037A908ABF521AD15B8FCAC960077B16CB4AFCB73FFEA7EA
B05D1BDF3B8A00B57F5375C49819775F172225EE93EE41B46031BBFF9AE8F0F0
1A5C693C866B320FEFB7B56B7F1A91344648FBA9A93CF961399EFC6843E35E01
01186B37B5B758FBC455D8E7D7F6696283209F1FCDE3144E42E6D545F970B7D3
8E51CC300DBC819EBA8F6AE1C140F96F371C8BE8132E6CEA5EAB4EE7A858408F
6EACFA14221F9ACD0E1EAFB22E2D9BB6681C63BCFC14214728D08DDD71FDCE0F
EFFE9E30CAD9DDA97E247F4282845D720CDB1EC9ED6D1BAD7D62C95E5F2E5334
DFBE3FC60776ACA4482CCEBF3BA5BDC40724BBA2757F26A222F8E7690F70D6FF
B3B06D217AEAF91BA5A5FD50FD3B67A009492105B81C78F8E0AB11BF427E2E18
450DD45CD8A3478958D7CAEED311C24934A226C909CA3C2BD454C2EDB088B450
34BDCA7F5D06F008930E7803AEC14367C09C4E1370FC23D6B9A1C00745EAC84B
C991DC495E6E7799A6E2B9FEC4F052E0C6C9BE91B89BFD2B13B5CED386A17373
3ABBCA8FA901CF2C1457EDC9CC8F9894E25AFE9B07749B0E3A73B5A491729057
FB195138E2976CDC7F144F40839FF356CFBBD6B3B90E52625476B4F0AA7B4031
48569D9741715FF22CBC9327EDDB16B92E9D2745AD67FE373F51C3D14A1FF76C
D9D503D5BFFDFD09B13418130BA661C02347A9D9D536DB0A7C202CD2DB8B26B8
27F6E45D14DD80F3D20224165CABBDAAF9846B893BA13C1A072798251F9119B1
98A95483E784102F7898075FE5B2DD247B5356A21B13148B3A6F7AFA9989EEDD
5E716548F56F5A09C1257CFAFD572E7ED6D1E5BDAD28D36FCAADD3CA5E7FC82E
2268EB4A5A8743F566E65983EA230EC0DAB0F6BAFE6B50AD3553CC250971A69B
2D426181A3E84C3E122D4CC74506411110F672CB67E59EAE0DB5CC98316C9476
9101C991E1982454831890233509F4C8B70A8C5D561D0BF577619B4BF6BE22FD
F794A89F2B219D9AD46584D0AA704B8BD71275B05D19E6DCA7068E8F6CBB6D81
2961939CD9378E07FB898E46B308B00F079E154392751088D46FF8A1800E4FEE
7E5CB3519EC7B7BEDF2FEAECBF54442E1D1884AB7F7545DFE45C2E8E1E0E3A13
D7686E468CFA3C6A088FF6CAE8D5AA8EBADCCF4764F140E727D505540BB17837
C57A191AA5E780C16716D8D05BDC8C76A8A70874E176A7CDDE7A9B8CF6AAC93D
9E0D3A9A779E9BCDD0B6C552A6F18C1254F9DCB9C588EE3EEA50839738A81E8C
C6B04E021A59364780530037B3DC5BC3579BC9BC493681A117D7DD0EB848BAAA
A796AF29D72624061A94D949740E22FB6C7E5A1BE68A84003CB6BA932C095AB8
6B2CEB5B90529F3463CBC4877E1D65A0ED30D69A704DF51586D0DFD0442C2BD9
89069CEA1A6F8ECA0FB7C61683F2D3F7B43EDBDE05ACE2751D0A3FA52CD38D81
F004452227ED9269F4C8513396FB8738F927D9BCA52713736EE880C2C7E1DFD0
A048A85300CAD850E3D6CE4900EEC2BD7BA3B5CAA057739E608D88618B09E31E
312A23FA146481DDE6CC8BF21B3399DC8B438D8F683875EBB10AB73C9E6AAE68
21F88EC5ACC4DDC7AC311370CB6CF14AFE45F62E8696F00BB480A85A88236C40
D13EB26A8923CDD6E4486778EF88749B1B86BCAAE32038EE2F222E06439CFE48
9F35DD98FE45EC3240B1897141EB38B1C4BAC987943386B0817F16ACB09CD543
3F5E182E717E8BBD4C2792F097DDE8D4E40F4F184217032C7D11BE9BF0E47BBC
9738485318D8104EA0017E8418231CAA4C93B378DCFD50B02D7382BB7CFA8266
FDECE430DDFCECA6FAAAB5BC2B1D3C3C45AA28635F217A95312B9263EC43DE42
86A38C07E92C96BD09660AA706482A4F3F582A145DB9A08689F59B5B4B3E991C
319F2A60B9FEC58E3EA3687C1C1A6EA743DD82039BD0E7EFFC6E1263B088DB2E
74A400D0F796BF9D143F9F5DA180198702B51E1675913F709BAC6D4938131E2B
1519317379609915AFFEE9C68D310F0011F9B865DD6F5131DAE30850FBAC9A03
AC4530476A6069A3B4916B1BFDB76286F1AFD023950140EAA5B01B168D5CE513
C6F4F3B22C5D45C4CABF7076994CECB7889AEBA5DE5FAAC75A92827A8F87370C
A2A04EFD67889E4BE4FB0EED322C871ADACA10A1639D5C3BA8E5BB27566FEB06
850C7603F13782B8B5123822897A393A173FD1A30C7492A0EFFA096A182D6C43
2B03DAD90DB0D56AD39266435A55CF84BA6EB377D3C53BBB0AFB
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600
(/home/dkahl/Documents/Masterarbeit/arbeiten/Masterarbeit/abschnitte/n-schleifen/fig/Jaxo_tmp.dvi)
@start /Fa 154[42 101[{}1 76.3801 /Fourier-Math-Extension
rf /Fb 140[23 23 7[18 18 27[53 11[36 65[{
 TeXBase1Encoding ReEncodeFont }6 58.049 /Utopia-Italic
rf /Fd 139[26 30 31 7[24 24 27[70 11[48 65[{
 TeXBase1Encoding ReEncodeFont }7 76.3802 /Utopia-Italic
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop  0 TeXcolorgray  Black 0 0 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 0
0 a 0 0 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 0 a 0 0 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 0 a 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray 1 TeXcolorgray 1 TeXcolorgray 1 TeXcolorgray
888 1232 1985 1229 v 1 TeXcolorgray 0 TeXcolorgray 361
-105 a @beginspecial @setspecial
Black 98 0 add -82 0 add 140 0 add -82 0 add 5 3 0 1.0 1.0 doublegluon
 
@endspecial @beginspecial
@setspecial
Black 224 0 add -82 0 add 266 0 add -82 0 add 5 3 0 1.0 1.0 doublegluon
 
@endspecial @beginspecial @setspecial
Black  {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 true 42 -180
-360 182 0 add -82 0 add 1.0 1.0 arc2
 
@endspecial
Black 1036 603 a Fd(A)p 0 TeXcolorgray Black 1579 w(A)p
0 TeXcolorgray Black 1834 1184 a(M)p 0 TeXcolorgray Black
1596 590 a(t)1634 560 y Fb(A)1624 619 y(i)12 b(j)p 0
TeXcolorgray Black 2061 590 a Fd(t)2099 560 y Fb(A)2095
619 y(j)c(i)p 0 TeXcolorgray Black 2055 1056 a Fa(e)2056
1066 y Fd(t)2091 1036 y Fb(M)2085 1086 y(s)t(r)p 0 TeXcolorgray
Black 1590 1056 a Fa(e)1591 1066 y Fd(t)1626 1036 y Fb(M)1619
1086 y(r)h(s)p 0 TeXcolorgray Black 1834 138 a Fd(i)h(r)p
0 TeXcolorgray Black 1490 943 a(j)g(r)p 0 TeXcolorgray
Black 1837 720 a(i)i(s)p 0 TeXcolorgray Black 2187 943
a(j)e(r)p 0 TeXcolorgray 361 -105 a @beginspecial @setspecial
Black  {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 false 14 -0
180 182 0 add -121 0 add 1.0 1.0 arc2


@endspecial @beginspecial @setspecial
Black -5 4 0 false 14 -180 0 182 0 add -121 0 add 1.0 1.0 doublegluearc
 
@endspecial @beginspecial
@setspecial
Black  {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 true 41.19 -0.029
-71.323 182.81 0 add -81.979 0 add 1.0 1.0 arc2
 
@endspecial @beginspecial @setspecial
Black  {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 true 41.19 -108.677
-179.971 181.19 0 add -81.979 0 add 1.0 1.0 arc2
 
@endspecial
1 TeXcolorgray 1 TeXcolorgray 885 3 1991 4 v 885 1234
4 1233 v 2872 1234 V 885 1236 1991 4 v 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
